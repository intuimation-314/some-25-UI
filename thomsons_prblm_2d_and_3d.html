<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Charges on a Circle / Sphere — 2D & 3D</title>
  <style>
    html, body { height: 100%; margin: 0; background: #000; overflow: hidden; }
    canvas { display:block; }
    #ui { position: fixed; left: 16px; bottom: 16px; display: flex; gap: 8px; z-index: 10; align-items: center; flex-wrap: wrap; }
    #rec { position: fixed; right: 16px; bottom: 16px; display: flex; gap: 8px; z-index: 10; }
    .btn { cursor: pointer; border: 1px solid #2a2a2a; background: #111; color: #fff; padding: 8px 12px; border-radius: 10px; font-size: 13px; opacity: .9; text-decoration: none; }
    .btn:disabled { opacity: .4; cursor: not-allowed; }
    .num, select { width: 100px; background:#111; color:#fff; border:1px solid #2a2a2a; border-radius:10px; padding:6px 8px; }
    .pill { padding: 6px 10px; border-radius: 999px; }
    #speedWrap, #snapWrap, #viewWrap, #modeWrap {
      display:flex; align-items:center; gap:8px; background:#111; border:1px solid #2a2a2a; color:#fff; padding:8px 12px; border-radius:10px;
    }
    #speed { width: 220px; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="modeWrap">
      <span>Mode</span>
      <select id="modeSel">
        <option value="3D" selected>3D (sphere)</option>
        <option value="2D">2D (circle)</option>
      </select>
    </div>

    <button id="play" class="btn pill">⏸ Pause</button>
    <button id="reset" class="btn pill">↺ Reset</button>

    <span class="btn pill" style="pointer-events:none">N =</span>
    <input id="nInput" class="num" type="number" min="2" max="200" step="1" value="4"/>
    <button data-n="4" class="btn pill">4</button>
    <button data-n="6" class="btn pill">6</button>
    <button data-n="8" class="btn pill">8</button>
    <button data-n="10" class="btn pill">10</button>
    <button data-n="12" class="btn pill">12</button>
    <button data-n="20" class="btn pill">20</button>

    <div id="speedWrap">
      <span>Speed</span>
      <input id="speed" type="range" min="0.25" max="10" step="0.25" value="2" />
      <span id="speedVal">2×</span>
    </div>

    <div id="snapWrap">
      <label><input id="snap" type="checkbox" checked/> Snap to solid (3D: 4,6,8,10,12,20)</label>
    </div>

    <div id="viewWrap">
      <label><input id="showRadials" type="checkbox" checked/> Center lines</label>
      <label><input id="showSphere" type="checkbox" checked/> Sphere/Circle</label>
      <label><input id="showSolid" type="checkbox" checked/> Solid (3D)</label>
      <label><input id="showCenterDot" type="checkbox" checked/> Center dot</label>
    </div>
  </div>

  <div id="rec">
    <button id="recStart" class="btn">● Start Recording</button>
    <button id="recStop" class="btn" disabled>■ Stop & Download</button>
    <a id="dlLast" class="btn" href="#" download style="display:none">⬇ Download last recording</a>
  </div>

  <canvas id="c"></canvas>

  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ===== Tunables =====
    let SIM_SPEED = 2.0;
    let SETTLE_SPEED_THRESH = 0.004;
    let SETTLE_FRAMES = 20;
    const OVERLAY_FADE_TIME = 0.45;

    // ===== Scene setup =====
    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 200);
    camera.position.set(0, 0, 6);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.08; controls.target.set(0,0,0);

    const amb = new THREE.AmbientLight(0xffffff, 0.95); scene.add(amb);

    window.addEventListener('resize', ()=>{
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // ===== Helpers =====
    function clamp(x,a,b){ return Math.max(a, Math.min(b,x)); }

    function makeDot(radius=0.13, color=0x4cc9f0){
      return new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), new THREE.MeshBasicMaterial({ color, transparent:true, opacity:1 }));
    }
    function makeLabel(text, scale=1){
      const cvs = document.createElement('canvas');
      const ctx = cvs.getContext('2d');
      const fs = 120; ctx.font = `${fs}px Inter, Arial, sans-serif`;
      const m = ctx.measureText(text); cvs.width = Math.ceil(m.width+24); cvs.height = fs+24;
      ctx.font = `${fs}px Inter, Arial, sans-serif`; ctx.fillStyle = '#fff'; ctx.textBaseline = 'top'; ctx.fillText(text,12,12);
      const tex = new THREE.CanvasTexture(cvs);
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false }));
      spr.scale.set(cvs.width/900*scale, cvs.height/900*scale, 1);
      return spr;
    }

    // ===== Geometry groups =====
    const R = 2.2;

    // 3D: sphere shell + lat/long
    const sphereGroup = new THREE.Group(); scene.add(sphereGroup);
    const sphereShell = new THREE.Mesh(
      new THREE.SphereGeometry(R, 64, 64),
      new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.06, depthWrite: false })
    );
    sphereGroup.add(sphereShell);

    function buildLatLongGrid(radius=R, latStep=15, lonStep=15, segs=128){
      const g = new THREE.Group();
      const mat = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.9 });
      for (let lat = -90 + latStep; lat <= 90 - latStep; lat += latStep){
        const phi = THREE.MathUtils.degToRad(lat);
        const z = radius * Math.sin(phi);
        const r = radius * Math.cos(phi);
        const pts = [];
        for (let i=0;i<=segs;i++){
          const t = 2*Math.PI * (i/segs);
          pts.push(new THREE.Vector3(r*Math.cos(t), r*Math.sin(t), z));
        }
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        g.add(new THREE.Line(geom, mat.clone()));
      }
      for (let lon = 0; lon < 360; lon += lonStep){
        const lambda = THREE.MathUtils.degToRad(lon);
        const pts = [];
        for (let i=0;i<=segs;i++){
          const t = 2*Math.PI * (i/segs);
          const x = radius * Math.cos(t);
          const z = radius * Math.sin(t);
          const xr = x * Math.cos(lambda);
          const yr = x * Math.sin(lambda);
          pts.push(new THREE.Vector3(xr, yr, z));
        }
        const geom = new THREE.BufferGeometry().setFromPoints(pts);
        g.add(new THREE.Line(geom, mat.clone()));
      }
      return g;
    }
    const latLongGrid = buildLatLongGrid(R, 15, 15, 192);
    sphereGroup.add(latLongGrid);

    // 2D: circle & axes
    const circleGroup = new THREE.Group(); scene.add(circleGroup);
    function buildCircle(radius=R, segs=256){
      const pts = [];
      for (let i=0;i<segs;i++){
        const t = 2*Math.PI * (i/segs);
        pts.push(new THREE.Vector3(radius*Math.cos(t), radius*Math.sin(t), 0));
      }
      const geom = new THREE.BufferGeometry().setFromPoints(pts);
      return new THREE.LineLoop(geom, new THREE.LineBasicMaterial({ color: 0x333333, transparent:true, opacity:0.9 }));
    }
    const circle = buildCircle(R, 384);
    const axes = new THREE.LineSegments(
      new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-R*1.2,0,0), new THREE.Vector3(R*1.2,0,0),
        new THREE.Vector3(0,-R*1.2,0), new THREE.Vector3(0,R*1.2,0),
      ]),
      new THREE.LineBasicMaterial({ color: 0x222222, transparent:true, opacity:0.9 })
    );
    circleGroup.add(circle, axes);
    circleGroup.visible = false;

    // Center dot
    const centerDot = new THREE.Mesh(
      new THREE.SphereGeometry(0.04, 12, 12),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    scene.add(centerDot);

    // ===== State =====
    let MODE = '3D'; // '2D' | '3D'
    let N = 4;

    let u = []; // 3D unit vectors
    let v = []; // 3D tangential velocities
    let dots = [];
    let labels = [];
    let radials = [];

    let angles = [];     // 2D current angles
    let targetAngles = []; // 2D targets
    let settleCounter = 0;

    const chargesGroup = new THREE.Group(); scene.add(chargesGroup);
    const radialGroup = new THREE.Group(); scene.add(radialGroup);

    // 3D solid overlay
    const overlayGroup = new THREE.Group(); overlayGroup.visible = false; scene.add(overlayGroup);
    let overlayMesh = null, overlayEdges = null;
    let overlayFade = 0, overlayFading = false;

    // ===== Platonic/targets (3D) =====
    function uniqueUnitVertsFromGeometry(geom){
      const out = []; const seen = new Map();
      const pos = geom.getAttribute('position');
      for (let i=0;i<pos.count;i++){
        const v = new THREE.Vector3().fromBufferAttribute(pos, i).normalize();
        const k = `${v.x.toFixed(4)},${v.y.toFixed(4)},${v.z.toFixed(4)}`;
        if (!seen.has(k)){ seen.set(k,true); out.push(v); }
      }
      return out;
    }
    function buildAntiprism10(radius){
      const theta = THREE.MathUtils.degToRad(54);
      const rxy = Math.sin(theta), z = Math.cos(theta);
      const verts = [];
      for (let k=0;k<5;k++){
        const a = 2*Math.PI*k/5;
        verts.push(new THREE.Vector3(rxy*Math.cos(a), rxy*Math.sin(a), z));
      }
      for (let k=0;k<5;k++){
        const a = 2*Math.PI*k/5 + Math.PI/5;
        verts.push(new THREE.Vector3(rxy*Math.cos(a), rxy*Math.sin(a), -z));
      }
      verts.forEach(v=> v.multiplyScalar(radius));
      const pos = []; const idx = [];
      verts.forEach(v=> pos.push(v.x, v.y, v.z));
      for (let k=0;k<5;k++){
        const t0=k, t1=(k+1)%5, b0=5+k, b1=5+((k+1)%5);
        idx.push(t0,b0,t1); idx.push(b0,b1,t1);
      }
      idx.push(0,1,2, 0,2,3, 0,3,4);
      idx.push(5,7,6, 5,8,7, 5,9,8);
      const geom = new THREE.BufferGeometry();
      geom.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
      geom.setIndex(idx);
      geom.computeVertexNormals();
      return geom;
    }
    function getTargetGeometry(count, radius){
      if (count === 4) return new THREE.TetrahedronGeometry(radius);
      if (count === 6) return new THREE.OctahedronGeometry(radius);
      if (count === 8){ const s = 2*radius/Math.sqrt(3); return new THREE.BoxGeometry(s, s, s); }
      if (count === 10) return buildAntiprism10(radius);
      if (count === 12) return new THREE.IcosahedronGeometry(radius);
      if (count === 20) return new THREE.DodecahedronGeometry(radius);
      return null;
    }
    function getTargetUnitVerts(count){
      const g = getTargetGeometry(count, 1);
      return g ? uniqueUnitVertsFromGeometry(g) : null;
    }
    function assignTargetsGreedy(targets, currents){
      const used = new Set(); const map = new Array(currents.length).fill(-1);
      for (let j=0;j<currents.length;j++){
        let bestI=-1, bestDot=-2;
        for (let i=0;i<targets.length;i++){
          if (used.has(i)) continue;
          const d = targets[i].dot(currents[j]);
          if (d>bestDot){ bestDot=d; bestI=i; }
        }
        if (bestI>=0){ used.add(bestI); map[j]=bestI; }
      }
      return map;
    }
    function alignQuaternion(targetsUnit, currentUnit){
      let i0=0, j0=0, best=-2;
      for (let i=0;i<targetsUnit.length;i++){
        for (let j=0;j<currentUnit.length;j++){
          const d = targetsUnit[i].dot(currentUnit[j]);
          if (d>best){ best=d; i0=i; j0=j; }
        }
      }
      const b0 = targetsUnit[i0].clone();
      const a0 = currentUnit[j0].clone();
      const q1 = new THREE.Quaternion().setFromUnitVectors(b0, a0);
      const proj = (v, n)=> v.clone().sub(n.clone().multiplyScalar(v.dot(n)));
      const b1p = targetsUnit[(i0+1)%targetsUnit.length].clone().applyQuaternion(q1);
      const a1p = proj(currentUnit[(j0+1)%currentUnit.length], a0).normalize();
      const b1pp = proj(b1p, a0).normalize();
      let ang = Math.acos(clamp(b1pp.dot(a1p), -1, 1));
      const cross = new THREE.Vector3().crossVectors(b1pp, a1p);
      if (cross.dot(a0) < 0) ang = -ang;
      const q2 = new THREE.Quaternion().setFromAxisAngle(a0, ang);
      return q2.multiply(q1);
    }
    function buildOverlay(count){
      const geom = getTargetGeometry(count, R);
      if (!geom) return { mesh:null, edges:null };
      const mesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({ color: 0x2a7cff, transparent: true, opacity: 0.0, side: THREE.DoubleSide, depthWrite: false }));
      let edges;
      if (count === 10){
        const posAttr = geom.getAttribute('position'); const V = [];
        for (let i=0;i<posAttr.count;i++){ V.push(new THREE.Vector3().fromBufferAttribute(posAttr,i)); }
        const pairs = [];
        for (let k=0;k<5;k++){
          const t=k, t1=(k+1)%5, b=5+k, b1=5+((k+1)%5);
          pairs.push([t,t1],[b,b1],[t,b],[t1,b]);
        }
        const linePos = [];
        for (const [a,b] of pairs){ linePos.push(V[a].x,V[a].y,V[a].z, V[b].x,V[b].y,V[b].z); }
        const lgeom = new THREE.BufferGeometry(); lgeom.setAttribute('position', new THREE.Float32BufferAttribute(linePos,3));
        edges = new THREE.LineSegments(lgeom, new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 }));
      } else {
        edges = new THREE.LineSegments(new THREE.EdgesGeometry(geom), new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0 }));
      }
      return { mesh, edges };
    }

    // ===== Init/clear =====
    function randomOnSphere(){
      let x,y,z, s;
      do { x = Math.random()*2-1; y = Math.random()*2-1; z = Math.random()*2-1; s = x*x+y*y+z*z; } while (s === 0 || s > 1);
      const l = Math.sqrt(s);
      return new THREE.Vector3(x/l, y/l, z/l);
    }

    function clearCharges(){
      dots.forEach(m=>chargesGroup.remove(m));
      labels.forEach(s=>chargesGroup.remove(s));
      radials.forEach(l=>radialGroup.remove(l));
      dots.forEach(m=>{ m.geometry.dispose(); m.material.dispose(); });
      labels.forEach(s=>{ s.material.map.dispose(); s.material.dispose(); });
      radials.forEach(l=>{ l.geometry.dispose(); l.material.dispose(); });
      u = []; v = []; dots = []; labels = []; radials = [];
      hideOverlay();
    }

    function initCharges(count){
      clearCharges();
      N = count;
      const radialMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.95 });
      for (let i=0;i<N;i++){
        const d = makeDot();
        const lab = makeLabel('e', 0.7);
        const line = new THREE.Line(new THREE.BufferGeometry(), radialMat.clone());
        dots.push(d); labels.push(lab); radials.push(line);
        chargesGroup.add(d); chargesGroup.add(lab); radialGroup.add(line);
      }

      if (MODE === '3D'){
        for (let i=0;i<N;i++){ u.push(randomOnSphere()); v.push(new THREE.Vector3()); }
        placeFromState3D();
      } else {
        angles = [];
        // random start around circle
        for (let i=0;i<N;i++){ angles.push(Math.random()*Math.PI*2); }
        setUniformTargets2D();
        placeFromState2D();
      }

      radialGroup.visible = showRadialsChk.checked;
      sphereGroup.visible = (MODE === '3D') && showSphereChk.checked;
      circleGroup.visible = (MODE === '2D') && showSphereChk.checked;
      overlayGroup.visible = (MODE === '3D') && showSolidChk.checked && !!overlayMesh;
      centerDot.visible = showCenterDotChk.checked;
    }

    function placeFromState3D(){
      for (let i=0;i<N;i++){
        const p = u[i].clone().multiplyScalar(R);
        dots[i].position.copy(p);
        labels[i].position.copy(p);
        radials[i].geometry.setFromPoints([new THREE.Vector3(0,0,0), p]);
      }
    }
    function placeFromState2D(){
      for (let i=0;i<N;i++){
        const x = R*Math.cos(angles[i]), y = R*Math.sin(angles[i]);
        const p = new THREE.Vector3(x,y,0);
        dots[i].position.copy(p);
        labels[i].position.copy(p);
        radials[i].geometry.setFromPoints([new THREE.Vector3(0,0,0), p]);
      }
    }

    // ===== Physics / motion =====
    const k = 1.0;
    const damping = 1.2;
    let snapEnabled = true;

    function step3D(dt){
      const r = u.map(ui => ui.clone().multiplyScalar(R));
      const F = new Array(N).fill(null).map(()=> new THREE.Vector3());
      for (let i=0;i<N;i++){
        for (let j=i+1;j<N;j++){
          const d = r[i].clone().sub(r[j]);
          const dist = Math.max(d.length(), 1e-5);
          const f = d.multiplyScalar(k/(dist*dist*dist));
          F[i].add(f); F[j].sub(f);
        }
      }

      const targetUnit = getTargetUnitVerts(N);
      if (snapEnabled && targetUnit && targetUnit.length === N){
        const q = alignQuaternion(targetUnit, u);
        const oriented = targetUnit.map(v=> v.clone().applyQuaternion(q));
        const assign = assignTargetsGreedy(oriented, u);
        const guideK = 1.2;
        for (let j=0;j<N;j++){
          const i = assign[j]; if (i<0) continue;
          const ui = u[j]; const tgt = oriented[i];
          const delta = tgt.clone().sub(ui.clone().multiplyScalar(ui.dot(tgt)));
          F[j].add(delta.multiplyScalar(guideK));
        }
      }

      let avgSpeed = 0;
      const damp = Math.exp(-damping*dt);
      for (let i=0;i<N;i++){
        const ui = u[i];
        v[i].add(F[i].multiplyScalar(dt));
        v[i].sub(ui.clone().multiplyScalar(v[i].dot(ui)));
        v[i].multiplyScalar(damp);
        avgSpeed += v[i].length();
        u[i].add(v[i].clone().multiplyScalar(dt / R));
        u[i].normalize();
      }
      avgSpeed /= Math.max(1,N);
      const scaledThresh = SETTLE_SPEED_THRESH * Math.sqrt(SIM_SPEED);
      if (avgSpeed < scaledThresh) settleCounter++; else settleCounter = 0;

      placeFromState3D();
      if (settleCounter > SETTLE_FRAMES){ showAlignedOverlay(); }
    }

    // 2D: ease angles toward uniform spacing on the circle
    function setUniformTargets2D(){
      targetAngles = [];
      const phase = 0; // you could rotate the whole configuration if you want
      for (let i=0;i<N;i++){ targetAngles.push(phase + 2*Math.PI*i/N); }
    }
    function wrapAngle(a){
      while (a > Math.PI) a -= 2*Math.PI;
      while (a < -Math.PI) a += 2*Math.PI;
      return a;
    }
    function step2D(dt){
      // critically damped easing toward targetAngles
      const kAngle = 4.0; // attraction to targets
      let maxErr = 0;
      for (let i=0;i<N;i++){
        const err = wrapAngle(targetAngles[i] - angles[i]);
        angles[i] += err * (kAngle * dt * SIM_SPEED);
        maxErr = Math.max(maxErr, Math.abs(err));
      }
      placeFromState2D();
      // consider settled when max angle error small
      if (maxErr < 1e-3) settleCounter++; else settleCounter = 0;
    }

    function hideOverlay(){
      overlayGroup.visible = false; overlayFading = false; overlayFade = 0;
      if (overlayMesh){ overlayGroup.remove(overlayMesh); overlayMesh.geometry.dispose(); overlayMesh.material.dispose(); overlayMesh = null; }
      if (overlayEdges){ overlayGroup.remove(overlayEdges); overlayEdges.geometry.dispose(); overlayEdges.material.dispose(); overlayEdges = null; }
    }
    function showAlignedOverlay(){
      if (MODE !== '3D' || !showSolidChk.checked) return;
      if (overlayMesh || overlayEdges) { overlayGroup.visible = true; return; }
      const geom = getTargetGeometry(N, R);
      if (!geom) { hideOverlay(); return; }
      const unitVerts = getTargetUnitVerts(N);
      const q = alignQuaternion(unitVerts, u);
      const { mesh, edges } = buildOverlay(N);
      overlayMesh = mesh; overlayEdges = edges;
      overlayGroup.add(overlayMesh, overlayEdges);
      overlayGroup.quaternion.copy(q);
      overlayGroup.visible = true;
      overlayFade = 0; overlayFading = true;
    }

    // ===== Controls =====
    const playBtn = document.getElementById('play');
    const resetBtn = document.getElementById('reset');
    const nInput = document.getElementById('nInput');
    const nPresetBtns = [...document.querySelectorAll('[data-n]')];
    const speedSlider = document.getElementById('speed');
    const speedVal = document.getElementById('speedVal');
    const snapChk = document.getElementById('snap');
    const showRadialsChk = document.getElementById('showRadials');
    const showSphereChk  = document.getElementById('showSphere');
    const showSolidChk   = document.getElementById('showSolid');
    const showCenterDotChk = document.getElementById('showCenterDot');
    const modeSel = document.getElementById('modeSel');

    let running = true;

    playBtn.addEventListener('click', ()=>{
      running = !running; playBtn.textContent = running ? '⏸ Pause' : '▶ Play';
    });

    function resetAll(){
      hideOverlay();
      initCharges(parseInt(nInput.value||N,10));
      settleCounter = 0;
    }
    resetBtn.addEventListener('click', resetAll);

    nInput.addEventListener('change', ()=>{ const val = clamp(parseInt(nInput.value||N,10), 2, 200); nInput.value = val; resetAll(); });
    nPresetBtns.forEach(b=> b.addEventListener('click', ()=>{ nInput.value = parseInt(b.dataset.n,10); resetAll(); }));

    function updateSpeed(val){
      SIM_SPEED = parseFloat(val) || 1;
      const txt = (Math.round(SIM_SPEED * 100) / 100).toString().replace(/\.00$/, '');
      speedVal.textContent = `${txt}×`;
    }
    speedSlider.addEventListener('input', ()=> updateSpeed(speedSlider.value));
    updateSpeed(speedSlider.value);

    snapChk.addEventListener('change', ()=>{ snapEnabled = !!snapChk.checked; });

    // Visibility toggles
    radialGroup.visible = showRadialsChk.checked;
    sphereGroup.visible = (MODE === '3D') && showSphereChk.checked;
    circleGroup.visible = (MODE === '2D') && showSphereChk.checked;
    overlayGroup.visible = (MODE === '3D') && showSolidChk.checked && !!overlayMesh;
    centerDot.visible = showCenterDotChk.checked;

    showRadialsChk.addEventListener('change', ()=>{ radialGroup.visible = !!showRadialsChk.checked; });
    showSphereChk.addEventListener('change', ()=>{
      sphereGroup.visible = (MODE === '3D') && !!showSphereChk.checked;
      circleGroup.visible = (MODE === '2D') && !!showSphereChk.checked;
    });
    showSolidChk.addEventListener('change', ()=>{
      if (MODE !== '3D' || !showSolidChk.checked){ overlayGroup.visible = false; }
      else { overlayGroup.visible = !!overlayMesh; }
    });
    showCenterDotChk.addEventListener('change', ()=>{ centerDot.visible = !!showCenterDotChk.checked; });

    modeSel.addEventListener('change', ()=>{
      MODE = modeSel.value;
      // snap toggle only meaningful in 3D
      snapChk.disabled = (MODE === '2D');
      resetAll();
    });

    // ===== Tiny self-tests =====
    function testTargets(){
      const cases = [4,6,8,10,12,20];
      const results = cases.map(n=>{
        const g = getTargetGeometry(n, 1);
        const verts = g ? uniqueUnitVertsFromGeometry(g) : [];
        return { N:n, uniqueVerts: verts.length, ok: verts.length === n };
      });
      console.table(results);
      const allOk = results.every(r=>r.ok);
      if (!allOk) console.warn('Target vertex counts mismatch for some N');
    }
    window.TEST = { testTargets };
    testTargets();

    // Start
    initCharges(4);

    // ===== Animate =====
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033);
      controls.update();

      if (running){
        if (MODE === '3D') step3D(dt * SIM_SPEED);
        else step2D(dt * SIM_SPEED);
      }

      if (overlayFading){
        overlayFade = Math.min(1, overlayFade + dt/OVERLAY_FADE_TIME);
        if (overlayMesh) overlayMesh.material.opacity = 0.18 * overlayFade;
        if (overlayEdges) overlayEdges.material.opacity = 1.0 * overlayFade;
        if (overlayFade >= 1) overlayFading = false;
      }

      renderer.render(scene, camera);
    }
    animate();

    // ===== Recording =====
    const recStartBtn = document.getElementById('recStart');
    const recStopBtn = document.getElementById('recStop');
    const dlLast = document.getElementById('dlLast');
    let mediaRecorder = null; let chunks = []; let lastUrl = null; let lastExt = 'webm';

    function getSupportedMime(){
      const candidates = [
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm',
        'video/mp4;codecs=avc1'
      ];
      for (const c of candidates){ if (window.MediaRecorder && MediaRecorder.isTypeSupported(c)) return c; }
      return '';
    }

    recStartBtn.addEventListener('click', ()=>{
      const stream = renderer.domElement.captureStream(60);
      const mime = getSupportedMime();
      try {
        mediaRecorder = new MediaRecorder(stream, { mimeType: mime || undefined, videoBitsPerSecond: 8_000_000 });
      } catch (e){
        mediaRecorder = new MediaRecorder(stream);
      }
      chunks = [];
      mediaRecorder.ondataavailable = (e)=>{ if (e.data && e.data.size) chunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        const type = mediaRecorder.mimeType || 'video/webm';
        const blob = new Blob(chunks, { type });
        if (lastUrl) URL.revokeObjectURL(lastUrl);
        lastUrl = URL.createObjectURL(blob);
        lastExt = type.includes('mp4') ? 'mp4' : 'webm';
        const filename = `charges_${MODE}_${N}_${Date.now()}.${lastExt}`;
        const a = document.createElement('a');
        a.href = lastUrl; a.download = filename; document.body.appendChild(a); a.click(); setTimeout(()=>a.remove(), 100);
        dlLast.href = lastUrl; dlLast.download = filename; dlLast.style.display = 'inline-block';
      };
      mediaRecorder.start();
      recStartBtn.disabled = true; recStopBtn.disabled = false;
    });

    recStopBtn.addEventListener('click', ()=>{
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      recStartBtn.disabled = false; recStopBtn.disabled = true;
    });
  </script>
</body>
</html>
